<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Pac-Man Clone</title>
    <style>
        body { background: black; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        canvas { border: 1px solid white; background: black; }
        #score { color: yellow; font-family: Arial; font-size: 20px; position: absolute; top: 10px; left: 10px; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas" width="380" height="420"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 20;
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,2,2,2,2,0,2,2,2,2,2,1,0,0,0],
            [1,1,1,1,2,1,1,1,1,0,1,1,1,1,2,1,1,1,1],
            [2,2,2,2,2,1,2,2,2,0,2,2,2,1,2,2,2,2,2],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ]; // 1=wall, 2=dot, 0=empty

        let pacman = { x: 9, y: 14, dir: 'right', mouthOpen: true };
        let ghost = { x: 9, y: 8, dir: 'up' };
        let score = 0;
        let gameOver = false;

        function drawMaze() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    } else if (maze[y][x] === 2) {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            const angle = pacman.mouthOpen ? 0.2 : 0;
            let startAngle, endAngle;
            if (pacman.dir === 'right') { startAngle = angle * Math.PI; endAngle = (2 - angle) * Math.PI; }
            else if (pacman.dir === 'left') { startAngle = (1 + angle) * Math.PI; endAngle = (1 - angle) * Math.PI; }
            else if (pacman.dir === 'up') { startAngle = (1.5 + angle) * Math.PI; endAngle = (1.5 - angle) * Math.PI; }
            else { startAngle = (0.5 + angle) * Math.PI; endAngle = (0.5 - angle) * Math.PI; }
            ctx.arc(pacman.x * tileSize + tileSize / 2, pacman.y * tileSize + tileSize / 2, tileSize / 2, startAngle, endAngle);
            ctx.lineTo(pacman.x * tileSize + tileSize / 2, pacman.y * tileSize + tileSize / 2);
            ctx.fill();
            pacman.mouthOpen = !pacman.mouthOpen;
        }

        function drawGhost() {
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(ghost.x * tileSize + tileSize / 2, ghost.y * tileSize + tileSize / 2, tileSize / 2, 0, Math.PI * 2);
            ctx.fillRect(ghost.x * tileSize, ghost.y * tileSize + tileSize / 2, tileSize, tileSize / 2);
            ctx.fill();
        }

        function movePacman(dx, dy, newDir) {
            const newX = pacman.x + dx;
            const newY = pacman.y + dy;
            if (newX >= 0 && newX < maze[0].length && newY >= 0 && newY < maze.length && maze[newY][newX] !== 1) {
                pacman.x = newX;
                pacman.y = newY;
                pacman.dir = newDir;
                if (maze[newY][newX] === 2) {
                    maze[newY][newX] = 0;
                    score += 10;
                    document.getElementById('score').innerText = `Score: ${score}`;
                }
            }
        }

        function moveGhost() {
            const directions = [
                { dx: 0, dy: -1, dir: 'up' },
                { dx: 0, dy: 1, dir: 'down' },
                { dx: -1, dy: 0, dir: 'left' },
                { dx: 1, dy: 0, dir: 'right' }
            ];
            const validMoves = directions.filter(d => {
                const nx = ghost.x + d.dx;
                const ny = ghost.y + d.dy;
                return nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] !== 1;
            });
            if (validMoves.length > 0) {
                const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                ghost.x += move.dx;
                ghost.y += move.dy;
                ghost.dir = move.dir;
            }
        }

        function checkCollision() {
            if (pacman.x === ghost.x && pacman.y === ghost.y) {
                gameOver = true;
                alert('Game Over! Score: ' + score);
            }
        }

        function gameLoop() {
            if (gameOver) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            drawPacman();
            drawGhost();
            checkCollision();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', e => {
            if (gameOver) return;
            switch (e.key) {
                case 'ArrowRight': movePacman(1, 0, 'right'); break;
                case 'ArrowLeft': movePacman(-1, 0, 'left'); break;
                case 'ArrowUp': movePacman(0, -1, 'up'); break;
                case 'ArrowDown': movePacman(0, 1, 'down'); break;
            }
        });

        setInterval(moveGhost, 200); // Ghost moves every 200ms
        gameLoop();
    </script>
</body>
</html>
