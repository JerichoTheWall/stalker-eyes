<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Ship</title>
    <style>
        body { margin:0; padding:0; background:#000; overflow:hidden; }
        canvas { display:block; }
    </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

<script>
class MainScene extends Phaser.Scene {
    constructor() { super('main'); }

    create() {
        const WORLD_W = 1800;
        const WORLD_H = 1200;

        this.cameras.main.setBackgroundColor('#000000');
        this.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);
        this.cameras.main.setBounds(0, 0, WORLD_W, WORLD_H);

        // Floor + walls
        const gfx = this.add.graphics();
        gfx.fillStyle(0x111133);
        gfx.fillRect(0, 0, WORLD_W, WORLD_H);
        gfx.fillStyle(0x444466);
        const pillars = [[600,450,300,800],[1200,400,400,250],[850,800,500,300],[300,800,200,400],[1400,750,300,500]];
        this.walls = this.physics.add.staticGroup();
        pillars.forEach(p => {
            const [x,y,w,h] = p;
            this.walls.create(x,y).setSize(w,h).setVisible(false);
            gfx.fillRect(x-w/2, y-h/2, w, h);
        });

        // Player
        this.player = this.physics.add.sprite(250, 600, null).setCircle(20).setTint(0x00ff99);
        this.player.lastAngle = 0;
        this.player.batteries = [];
        this.player.currentCharge = 0;
        this.player.hasFlashlight = false;
        this.physics.add.collider(this.player, this.walls);
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

        // Flashlight pickup (glowing white circle)
        this.flashlightItem = this.physics.add.sprite(1500, 900, null).setCircle(18).setTint(0xffffff);
        this.physics.add.overlap(this.player, this.flashlightItem, () => {
            this.player.hasFlashlight = true;
            this.player.currentCharge = 100;
            this.batteryText.setText('Battery: 100%');
            this.flashlightItem.destroy();
        });

        // Batteries (yellow)
        for (let i = 0; i < 10; i++) {
            let b = this.physics.add.sprite(Phaser.Math.Between(200,1600), Phaser.Math.Between(200,1000), null)
                .setCircle(14).setTint(0xffff00);
            this.physics.add.overlap(this.player, b, () => {
                this.player.batteries.push(100);
                b.destroy();
            });
        }

        // Enemies
        this.enemies = this.physics.add.group();
        for (let i = 0; i < 8; i++) {
            let e = this.enemies.create(Phaser.Math.Between(700,1300), Phaser.Math.Between(300,900), null)
                .setCircle(20).setTint(0x110011);
            e.health = 100;
        }
        this.physics.add.collider(this.enemies, this.walls);

        // Darkness overlay
        this.darkness = this.make.graphics().fillStyle(0x000000).fillRect(0,0,4000,4000);
        this.darknessMask = this.darkness.createGeometryMask();
        this.darkness.setDepth(20);
        this.darkness.setAlpha(0.97);
        this.light = this.add.graphics().setDepth(21);
        this.light.setBlendMode(Phaser.BlendModes.ERASE);

        // UI
        this.healthText = this.add.text(20,20,'Health: 100',{font:'32px Arial',fill:'#ff3333'}).setScrollFactor(0).setDepth(30);
        this.batteryText = this.add.text(20,70,'Find the flashlight!',{font:'30px Arial',fill:'#ffff55'}).setScrollFactor(0).setDepth(30);

        // Mobile controls
        this.joystick = {active:false, x:0, y:0, force:0, angle:0};
        this.joyBase = this.add.circle(0,0,100,0xffffff,0.2).setDepth(30).setVisible(false);
        this.joyThumb = this.add.circle(0,0,50,0xffffff,0.7).setDepth(30).setVisible(false);

        this.flashlightOn = false;
        this.sprinting = false;
        this.sprintTime = 0;
        this.playerHealth = 100;

        this.input.on('pointerdown', p => {
            if (p.x < this.scale.width/2) {
                // Joystick
                this.joystick.active = true;
                this.joystick.x = p.x; this.joystick.y = p.y;
                this.joyBase.setPosition(p.x,p.y).setVisible(true);
                this.joyThumb.setPosition(p.x,p.y).setVisible(true);
            } else {
                // Right side = toggle flashlight or sprint
                if (this.player.hasFlashlight) this.flashlightOn = !this.flashlightOn;
                this.sprinting = true;
                this.sprintTime = 4;
            }
        });

        this.input.on('pointermove', p => {
            if (!this.joystick.active) return;
            const dx = p.x - this.joystick.x;
            const dy = p.y - this.joystick.y;
            const dist = Math.hypot(dx,dy);
            const max = 100;
            if (dist > max) {
                this.joyThumb.setPosition(this.joystick.x + dx*max/dist, this.joystick.y + dy*max/dist);
                this.joystick.force = 1;
            } else {
                this.joyThumb.setPosition(p.x, p.y);
                this.joystick.force = dist/max;
            }
            this.joystick.angle = Math.atan2(dy,dx);
        });

        this.input.on('pointerup', () => {
            this.joystick.active = false;
            this.joyBase.setVisible(false);
            this.joyThumb.setVisible(false);
            this.sprinting = false;
        });
    }

    update(time, delta) {
        delta /= 1000;

        // Movement
        let speed = this.sprinting && |this.sprintTime > 0 ? 380 : 180;
        if (this.sprintTime > 0) this.sprintTime -= delta;

        let vx = 0, vy = 0;
        if (this.joystick.active && this.joystick.force > 0.2) {
            vx = Math.cos(this.joystick.angle) * speed * this.joystick.force;
            vy = Math.sin(this.joystick.angle) * speed * this.joystick.force;
            this.player.lastAngle = this.joystick.angle;
        }
        this.player.setVelocity(vx, vy);

        // Battery drain
        if (this.flashlightOn && this.player.hasFlashlight && this.player.currentCharge > 0) {
            this.player.currentCharge -= 20 * delta;
            if (this.player.currentCharge <= 0) {
                if (this.player.batteries.length) this.player.currentCharge = this.player.batteries.shift();
                else this.flashlightOn = false;
            }
            this.batteryText.setText(`Battery: ${Math.round(this.player.currentCharge)}% (${this.player.batteries.length} left)`);
        }

        // Light cone
        this.light.clear();
        this.light.fillStyle(0xffffff);
        this.light.fillCircle(this.player.x, this.player.y, 90); // personal light

        if (this.flashlightOn && this.player.hasFlashlight) {
            const len = 420;
            const a = this.player.lastAngle;
            const spread = Phaser.Math.DegToRad(48);
            const lx = this.player.x + Math.cos(a-spread)*len;
            const ly = this.player.y + Math.sin(a-spread)*len;
            const rx = this.player.x + Math.cos(a+spread)*len;
            const ry = this.player.y + Math.sin(a+spread)*len;
            this.light.fillTriangle(this.player.x, this.player.y, lx, ly, rx, ry);
        }

        // Enemies
        this.enemies.getChildren().forEach(e => {
            const dx = this.player.x - e.x;
            const dy = this.player.y - e.y;
            const dist = Math.hypot(dx,dy);
            const angle = Math.atan2(dy,dx);

            if (dist < 50) {
                this.playerHealth -= 40 * delta;
                this.healthText.setText('Health: '+Math.round(this.playerHealth));
                if (this.playerHealth <= 0) {
                    this.physics.pause();
                    this.add.text(this.scale.width/2, this.scale.height/2, 'YOU DIED', 
                        {font:'100px Arial', fill:'#ff0000'}).setOrigin(0.5).setScrollFactor(0).setDepth(100);
                }
            }

            const speed = 120;
            if (dist > 70) e.setVelocity(Math.cos(angle)*speed, Math.sin(angle)*speed);
            else e.setVelocity(0,0);

            // Flashlight damage
            if (this.flashlightOn && this.player.hasFlashlight) {
                const angleDiff = Math.abs(Phaser.Math.Angle.Wrap(this.player.lastAngle - angle));
                if (dist < 400 && angleDiff < Phaser.Math.DegToRad(50)) {
                    e.health -= 60 * delta;
                    if (e.health <= 0) e.destroy();
                    e.setVelocity(-Math.cos(angle)*200, -Math.sin(angle)*200); // flee
                }
            }
        });
    }
}

// IMPORTANT: Fixed config - no window.innerWidth before DOM is ready
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    parent: document.body,
    physics: { default: 'arcade', arcade: { debug: false } },
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    backgroundColor: '#000000',
    scene: MainScene
};

new Phaser.Game(config);
</script>
</body>
</html>
